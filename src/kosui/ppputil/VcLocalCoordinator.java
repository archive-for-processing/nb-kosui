/*
 * Copyright (C) 2018 Key Parker from K.I.C.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package kosui.ppputil;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Queue;
import processing.core.PApplet;

import kosui.ppplocalui.EcComponent;
import kosui.ppplocalui.EcConst;
import kosui.ppplocalui.EcElement;
import kosui.ppplocalui.EcShape;
import kosui.ppplocalui.EcTipManager;
import kosui.ppplocalui.EiGroup;
import kosui.ppplocalui.EiTriggerable;

import static kosui.ppputil.VcConst.ccIsValidString;

/**
 * this should be just a container.
 * but we don't have to much to hold so this have to know more.
 */
public final class VcLocalCoordinator {
  
  public static final VcLocalCoordinator ccGetInstance(){return SELF;}
  private static final VcLocalCoordinator SELF = new VcLocalCoordinator();
  private VcLocalCoordinator(){}//..!
  
  //===
  
  private int
    cmMouseOverID=0,
    cmInputFocusID=0,
    cmInputIndex=0
  ;//...
  
  private final HashMap<Integer,EcElement> cmMapOfInputtable
    = new HashMap<Integer, EcElement>();
  private final HashMap<Integer, EiTriggerable> cmMapOfMouseTrigger
    = new HashMap<Integer, EiTriggerable>();
  private final HashMap<Integer, EiTriggerable> cmMapOfKeyTrigger
    = new HashMap<Integer, EiTriggerable>();
  
  private final Queue<EiTriggerable> cmQueueOfLoopTrigger
    = new LinkedList<EiTriggerable>();
  
  private final ArrayList<EcShape> cmListOfShape
    = new ArrayList<EcShape>();
  private final ArrayList<EcElement> cmListOfElement
    = new ArrayList<EcElement>();
  
  private final EcTipManager cmTipManager
    = new EcTipManager();

  //===
  
  /**
   * all focus will be initiated to zero but NOT "ignore".
   * @param pxOwner will get passed to EcComponent statics.
   */
  public final void ccInit(PApplet pxOwner) {
    if(pxOwner==null){return;}
    EcComponent.ccInitOwner(pxOwner);
  }//..!
  
  /**
   * <pre>
   * should be called inside draw().
   * thus coordinator for-each all component he holds,
   *   ccUpdate() of components should never
   *   be called directly from draw().
   * </pre>
   */
  static public final void ccUpdate(){
    if(!EcComponent.ccHasOwner()){return;}
    SELF.ssUpdate();
  }//+++
  
  private void ssUpdate(){
    
    //-- response to offer
    if(!cmQueueOfLoopTrigger.isEmpty()){
      cmQueueOfLoopTrigger.poll().ccTrigger();
    }//..?
    
    //-- turn on selected inputtable 
    for(EcElement it:cmMapOfInputtable.values()){
      it.ccSetIsActivated(it.ccGetID()==cmInputFocusID);
    }//..~
    
    //-- layer I
    for(EcShape it:cmListOfShape){
      it.ccUpdate();
    }//..~
    
    //-- layer II
    cmMouseOverID=0;
    for(EcElement it:cmListOfElement){
      it.ccUpdate();
      if(it.ccIsMouseHovered()){cmMouseOverID=it.ccGetID();}
    }//..~
    
    //-- layer III
    cmTipManager.ssUpdate(cmMouseOverID);
  
  }//+++
  
  //===
  
  /**
   * <pre>
   * the coordinator will do the offered job once a time per frame.
   * suppsedly to get called out of the AnimatedThread of PApplet.
   * yes, THE Event Dispatch Thread.
   * </pre>
   * @param pxTrigger to get invoked in the draw() loop
   */
  static public final void ccInvokeLater(EiTriggerable pxTrigger){
    if(pxTrigger==null){return;}
    SELF.cmQueueOfLoopTrigger.offer(pxTrigger);
  }//+++
  
  /**
   * <pre>
   * supposedly should get called from PApplet.mousePressed().
   * if something goes wrong this can cause a null exception.
   * </pre>
   */
  static public final void ccMousePressed(){
    if(SELF.cmMapOfMouseTrigger.isEmpty()){return;}
    int lpID=ccGetMouseOverID();
    if(!SELF.cmMapOfMouseTrigger.containsKey(lpID)){return;}
    SELF.cmMapOfMouseTrigger.get(lpID).ccTrigger();
  }//+++
  
  /**
   * <pre>
   * supposedly should get called from PApplet.keyPressed().
   * if something goes wrong this can cause a null exception.
   * </pre>
   * @param pxKeyCode generated by PApplet.keyPressed()
   */
  static public final void ccKeyPressed(int pxKeyCode){
    if(SELF.cmMapOfKeyTrigger.isEmpty()){return;}
    if(!SELF.cmMapOfKeyTrigger.containsKey(pxKeyCode)){return;}
    SELF.cmMapOfKeyTrigger.get(pxKeyCode).ccTrigger();
  }//+++
  
  //===
  
  /**
   * @param pxElement simply an alias to add()
   */
  static public final void ccAddElement(EcElement pxElement){
    if(pxElement==null){return;}
    if(SELF.cmListOfElement.contains(pxElement)){return;}
    SELF.cmListOfElement.add(pxElement);
  }//+++
  
  /**
   * @param pxList simply an alias to addAll()
   */
  static public final void ccAddElement(ArrayList<EcElement> pxList){
    if(pxList==null){return;}
    if(pxList.isEmpty()){return;}
    if(SELF.cmListOfElement.containsAll(pxList)){return;}
    SELF.cmListOfElement.addAll(pxList);
  }//+++
  
  /**
   * @param pxShape simply an alias to add()
   */
  static public final void ccAddShape(EcShape pxShape){
    if(pxShape==null){return;}
    if(SELF.cmListOfShape.contains(pxShape)){return;}
    SELF.cmListOfShape.add(pxShape);
  }//+++
  
  /**
   * @param pxList simply an alias to addAll()
   */
  static public final void ccAddShape(ArrayList<EcShape> pxList){
    if(pxList==null){return;}
    if(pxList.isEmpty()){return;}
    if(SELF.cmListOfShape.containsAll(pxList)){return;}
    SELF.cmListOfShape.addAll(pxList);
  }//+++
  
  /**
   * @param pxGroup #
   */
  static public final void ccAddGroup(EiGroup pxGroup){
    if(pxGroup==null){return;}
    ccAddShape(pxGroup.ccGiveShapeList());
    /*
    cmElementList.addAll(pxGroup.ccGiveElementList());
    cmShapeList.addAll(pxGroup.ccGiveShapeList());
    */
  }//+++
  
  /**
   * @param pxBox will be turned "on" if id matches. input logic is not here.
   */
  static public final void ccAddInputtable(EcElement pxBox){
    if(pxBox==null){return;}
    SELF.cmMapOfInputtable.put(pxBox.ccGetID(), pxBox);
    SELF.cmInputIndex=SELF.cmMapOfInputtable.size();
  }//+++
  
  /**
   * passed tip will always show if the element of passed id is mouse hovered
   * @param pxID #
   * @param pxTip #
   */
  static public final void ccAddTip(int pxID, String pxTip){
    if(!ccIsValidString(pxTip)){return;}
    SELF.cmTipManager.ccPut(pxID, pxTip);
  }//+++ 
  
  //===
  
  /**
   * 
   * @return id of current mouse hovered element
   */
  static public final int ccGetMouseOverID(){
    return SELF.cmMouseOverID;
  }//+++
  
  /**
   * 
   * @return focus id is not zero or "ignore"
   */
  static public final boolean ccHasInputtableFocused(){
    return SELF.cmInputFocusID!=0
        && SELF.cmInputFocusID!=EcConst.C_ID_IGNORE;
  }//+++
  
  /**
   * 
   * @return #
   */
  static public final int ccGetInputFocusID(){
    return SELF.cmInputFocusID;
  }//+++
  
  //===
  
  /**
   * just an alias to ccRegisterMouseTrigger(id, trigger)
   * @param pxElement #
   * @param pxTrigger #
   */
  static public final 
  void ccRegisterMouseTrigger(EcElement pxElement, EiTriggerable pxTrigger){
    ccRegisterMouseTrigger(pxElement.ccGetID(), pxTrigger);
  }//+++
  
  /**
   * @param pxElementID zero and ignore is omitted
   * @param pxTrigger don't pass null
   */
  static public final
  void ccRegisterMouseTrigger(int pxElementID, EiTriggerable pxTrigger){
    if(pxTrigger==null){return;}
    if(pxElementID==0){return;}
    if(pxElementID==EcConst.C_ID_IGNORE){return;}
    if(SELF.cmMapOfMouseTrigger.containsKey(pxElementID)){return;}
    SELF.cmMapOfMouseTrigger.put(pxElementID, pxTrigger);
  }//+++
  
  /**
   * <pre>
   * supposed the key code integer generated by PAapplet.keyPressed() 
   *   is exactly the value defined in awt key event.
   * </pre>
   * @param pxKeyCode virtual key value
   * @param pxTrigger don't pass null
   */
  static public final
  void ccRegisterKeyTrigger(int pxKeyCode, EiTriggerable pxTrigger){
    if(pxTrigger==null){return;}
    if(SELF.cmMapOfKeyTrigger.containsKey(pxKeyCode)){return;}
    SELF.cmMapOfKeyTrigger.put(pxKeyCode, pxTrigger);
  }//+++
  
  //===
  
  /**
   * set input focus to ignore id.
   * call this when you think a value has been taken
   */
  public final void ccClearCurrentInputFocus(){
    cmInputFocusID=EcConst.C_ID_IGNORE;
    cmInputIndex=cmMapOfInputtable.size();
  }//+++
  
  /**
   * set input focus to current mouse hovered element.
   * supposedly should be called from mousePressed().
   */
  public final void ccSetCurrentInputFocus(){
    cmInputFocusID=cmMouseOverID;
    cmInputIndex=cmMapOfInputtable.size();
  }//+++
  
  /**
   * set input focus to next indexed one in the list.
   * supposedly should be triggered by pressing [tab] key.
   */
  public final void ccToNextInputIndex(){
    cmInputIndex++;
    int lpSize=cmMapOfInputtable.size();
    if(cmInputIndex>lpSize){cmInputIndex=0;}
    if(cmInputIndex==lpSize){cmInputFocusID=EcConst.C_ID_IGNORE;return;}
    EcElement[] lpArray =new EcElement[lpSize];
    cmMapOfInputtable.values().toArray(lpArray);
    EcElement lpBox=lpArray[cmInputIndex];
    if(lpBox!=null){cmInputFocusID=lpBox.ccGetID();}
  }//+++
  
  /**
   * 
   * @return null if there is nothing focused so you have to check
   */
  public final EcElement ccGetCurrentFocusedBox(){
    if(cmInputFocusID==0
     ||cmInputFocusID==EcConst.C_ID_IGNORE
    ){return null;}
    return cmMapOfInputtable.get(cmInputFocusID);
  }//+++
  
}//***eof
